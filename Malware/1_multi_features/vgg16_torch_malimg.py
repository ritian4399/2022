import os
import torch
import torch.nn.functional as F
from torch.utils.data import DataLoader
import sys
from sklearn.model_selection import StratifiedKFold

# pretrained VGG
# from model.vgg16_1 import MalVgg16
from model.vgg16_2 import MalVgg16
from config.vgg16_config import Configure
from utils.MalimgDataset import MalimgDataset

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
def load_model(target_model, model_path):
    # 加载预模型
    if not os.path.exists(model_path):
        print("model path error")
        sys.exit(0)
    else:
        target_model.load_state_dict(torch.load(model_path))
        target_model.eval()


def train(model, epoch, train_loader, optimizer):
    for batch_idx, data in enumerate(train_loader, 0):
        optimizer.zero_grad()  # 梯度清0

        inputs, labels = data
        inputs, labels = inputs.to(device), labels.to(device)

        y_pred = model(inputs)  # 前向传播
        loss = torch.nn.functional.cross_entropy(y_pred, labels.long())  # 计算损失

        if batch_idx % 100 == 99:
            print("epoch=%d, loss=%f" % (epoch, loss.item()))

        loss.backward()  # 反向传播
        optimizer.step()  # 梯度更新

if __name__ == "__main__":
    config = Configure()
    train_set = MalimgDataset(config.base_path)
    train_loader = DataLoader(train_set, batch_size=config.batch_size, shuffle=True, num_workers=2)

    if Configure.load_model:
        model = MalVgg16()
        print("----load model-----")
        load_model(model, config.model_path)
    else:
        model = MalVgg16() # pretrained=True
    model.to(device)

    # 未导入外部模型
    if not Configure.load_model:
        optimizer = torch.optim.SGD(
            model.parameters(),
            lr = config.lr,
            weight_decay=config.decay,
            momentum=config.momentum
        )
    print("-----training begin-----")
    for i in range(config.epochs):
        train(model, i, train_loader, optimizer)