import glob
import os
import numpy
import shutil
import pandas as pd
import random
import numpy as np
# This is used for multithreading
import multiprocessing
from multiprocessing import Process

# This is used for file operations
import codecs
'''
get asm features from test set
'''
def firstprocess():
    asm_path = r"D:\research\datasets\3_malware\CCF_1_data_set\train_set\asm"
    os.chdir(asm_path)
    opcodes = ['jmp', 'mov', 'retf', 'push', 'pop', 'xor', 'retn', 'nop', 'sub', 'inc', 'dec', 'add', 'imul', 'xchg',
               'or', 'shr', 'cmp', 'call', 'shl', 'ror', 'rol', 'jnb', 'jz', 'rtn', 'lea', 'movzx']

    registers = ['edx', 'esi', 'eax', 'ebx', 'ecx', 'edi', 'ebp', 'esp', 'eip']

    keywords = ['.dll', 'std::', ':dword']

    file1 = open(r"output\firstprocess.txt", "w+")
    files = os.listdir('first')
    for f in files:

        opcodescount = np.zeros(len(opcodes), dtype=int)
        keywordcount = np.zeros(len(keywords), dtype=int)
        registerscount = np.zeros(len(registers), dtype=int)
        features = []
        f2 = f.split('.')[0]
        file1.write(f2 + ",")

        with codecs.open('first/' + f, encoding='cp1252', errors='replace') as fli:
            for lines in fli:
                if lines in ['\n','\r\n'] or lines.strip() == "":
                    continue
                # https://www.tutorialspoint.com/python3/string_rstrip.htm
                line = lines.rstrip().split()
                l = line[0]

                # Counting the prefixs in each and every line
                # for i in range(len(prefixes)):
                #     if prefixes[i] in line[0]: # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:'...
                #         prefixescount[i] += 1
                # line = line[1:]

                # Counting the opcodes in each and every line
                for i in range(len(opcodes)):
                    if any(opcodes[i] == li for li in line):
                        features.append(opcodes[i])
                        opcodescount[i] += 1
                # Counting registers in the line
                for i in range(len(registers)):
                    for li in line:
                        # We will use registers only in 'text' and 'CODE' segments
                        # if registers[i] in li and ('text' in l or 'CODE' in l):
                        if registers[i] in li:
                            registerscount[i] += 1
                # Counting keywords in the line
                for i in range(len(keywords)):
                    for li in line:
                        if keywords[i] in li:
                            keywordcount[i] += 1
        # Pushing the values into the file after reading whole file
        # for prefix in prefixescount:
        #     file1.write(str(prefix) + ",")
        for opcode in opcodescount:
            file1.write(str(opcode) + ",")
        for register in registerscount:
            file1.write(str(register) + ",")
        for key in keywordcount:
            file1.write(str(key) + ",")
        file1.write("\n")
    file1.close()
def secondprocess():
    asm_path = r"D:\research\datasets\3_malware\CCF_1_data_set\train_set\asm"
    os.chdir(asm_path)
    # https://en.wikipedia.org/wiki/Data_segment
    # The prefixes tells about the segments that are present in the asm files
    # There are 450 segments(approx) present in all asm files.
    # These prefixes are best segments that gives us best values.
    # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:', '.data:', '.bss:', '.rdata:', '.edata:', '.rsrc:', '.tls:',
    #             '.reloc:', '.BSS:', '.CODE']

    # https://en.wikipedia.org/wiki/X86_instruction_listings
    # These are opcodes that are used to get best results
    opcodes = ['jmp', 'mov', 'retf', 'push', 'pop', 'xor', 'retn', 'nop', 'sub', 'inc', 'dec', 'add', 'imul', 'xchg',
               'or', 'shr', 'cmp', 'call', 'shl', 'ror', 'rol', 'jnb', 'jz', 'rtn', 'lea', 'movzx']

    # Below taken registers are general purpose registers and special registers
    # All the registers which are taken are best
    registers = ['edx', 'esi', 'eax', 'ebx', 'ecx', 'edi', 'ebp', 'esp', 'eip']

    # Best keywords that are taken from different blogs
    keywords = ['.dll', 'std::', ':dword']

    file1 = open(r"output\secondprocess.txt", "w+")
    files = os.listdir('second')
    for f in files:
        # Filling the values with zeros into the arrays
        # prefixescount = np.zeros(len(prefixes), dtype=int)
        opcodescount = np.zeros(len(opcodes), dtype=int)
        keywordcount = np.zeros(len(keywords), dtype=int)
        registerscount = np.zeros(len(registers), dtype=int)
        features = []
        f2 = f.split('.')[0]
        file1.write(f2 + ",")
        # opcodefile.write(f2 + " ")

        # https://docs.python.org/3/library/codecs.html#codecs.ignore_errors
        # https://docs.python.org/3/library/codecs.html#codecs.Codec.encode
        with codecs.open('second/' + f, encoding='cp1252', errors='replace') as fli:
            for lines in fli:
                if lines in ['\n','\r\n'] or lines.strip() == "":
                    continue
                # https://www.tutorialspoint.com/python3/string_rstrip.htm
                line = lines.rstrip().split()
                l = line[0]

                # Counting the prefixs in each and every line
                # for i in range(len(prefixes)):
                #     if prefixes[i] in line[0]: # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:'...
                #         prefixescount[i] += 1
                # line = line[1:]

                # Counting the opcodes in each and every line
                for i in range(len(opcodes)):
                    if any(opcodes[i] == li for li in line):
                        features.append(opcodes[i])
                        opcodescount[i] += 1
                # Counting registers in the line
                for i in range(len(registers)):
                    for li in line:
                        # We will use registers only in 'text' and 'CODE' segments
                        # if registers[i] in li and ('text' in l or 'CODE' in l):
                        if registers[i] in li:
                            registerscount[i] += 1
                # Counting keywords in the line
                for i in range(len(keywords)):
                    for li in line:
                        if keywords[i] in li:
                            keywordcount[i] += 1
        # Pushing the values into the file after reading whole file
        # for prefix in prefixescount:
        #     file1.write(str(prefix) + ",")
        for opcode in opcodescount:
            file1.write(str(opcode) + ",")
        for register in registerscount:
            file1.write(str(register) + ",")
        for key in keywordcount:
            file1.write(str(key) + ",")
        file1.write("\n")
    file1.close()
def thirdprocess():
    asm_path = r"D:\research\datasets\3_malware\CCF_1_data_set\train_set\asm"
    os.chdir(asm_path)
    # https://en.wikipedia.org/wiki/Data_segment
    # The prefixes tells about the segments that are present in the asm files
    # There are 450 segments(approx) present in all asm files.
    # These prefixes are best segments that gives us best values.
    # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:', '.data:', '.bss:', '.rdata:', '.edata:', '.rsrc:', '.tls:',
    #             '.reloc:', '.BSS:', '.CODE']

    # https://en.wikipedia.org/wiki/X86_instruction_listings
    # These are opcodes that are used to get best results
    opcodes = ['jmp', 'mov', 'retf', 'push', 'pop', 'xor', 'retn', 'nop', 'sub', 'inc', 'dec', 'add', 'imul', 'xchg',
               'or', 'shr', 'cmp', 'call', 'shl', 'ror', 'rol', 'jnb', 'jz', 'rtn', 'lea', 'movzx']

    # Below taken registers are general purpose registers and special registers
    # All the registers which are taken are best
    registers = ['edx', 'esi', 'eax', 'ebx', 'ecx', 'edi', 'ebp', 'esp', 'eip']

    # Best keywords that are taken from different blogs
    keywords = ['.dll', 'std::', ':dword']

    file1 = open(r"output\thirdprocess.txt", "w+")
    files = os.listdir('third')
    for f in files:
        # Filling the values with zeros into the arrays
        # prefixescount = np.zeros(len(prefixes), dtype=int)
        opcodescount = np.zeros(len(opcodes), dtype=int)
        keywordcount = np.zeros(len(keywords), dtype=int)
        registerscount = np.zeros(len(registers), dtype=int)
        features = []
        f2 = f.split('.')[0]
        file1.write(f2 + ",")
        # opcodefile.write(f2 + " ")

        # https://docs.python.org/3/library/codecs.html#codecs.ignore_errors
        # https://docs.python.org/3/library/codecs.html#codecs.Codec.encode
        with codecs.open('third/' + f, encoding='cp1252', errors='replace') as fli:
            for lines in fli:
                if lines in ['\n','\r\n'] or lines.strip() == "":
                    continue
                # https://www.tutorialspoint.com/python3/string_rstrip.htm
                line = lines.rstrip().split()
                l = line[0]

                # Counting the prefixs in each and every line
                # for i in range(len(prefixes)):
                #     if prefixes[i] in line[0]: # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:'...
                #         prefixescount[i] += 1
                # line = line[1:]

                # Counting the opcodes in each and every line
                for i in range(len(opcodes)):
                    if any(opcodes[i] == li for li in line):
                        features.append(opcodes[i])
                        opcodescount[i] += 1
                # Counting registers in the line
                for i in range(len(registers)):
                    for li in line:
                        # We will use registers only in 'text' and 'CODE' segments
                        # if registers[i] in li and ('text' in l or 'CODE' in l):
                        if registers[i] in li:
                            registerscount[i] += 1
                # Counting keywords in the line
                for i in range(len(keywords)):
                    for li in line:
                        if keywords[i] in li:
                            keywordcount[i] += 1
        # Pushing the values into the file after reading whole file
        # for prefix in prefixescount:
        #     file1.write(str(prefix) + ",")
        for opcode in opcodescount:
            file1.write(str(opcode) + ",")
        for register in registerscount:
            file1.write(str(register) + ",")
        for key in keywordcount:
            file1.write(str(key) + ",")
        file1.write("\n")
    file1.close()
def fourthprocess():
    asm_path = r"D:\research\datasets\3_malware\CCF_1_data_set\train_set\asm"
    os.chdir(asm_path)
    # https://en.wikipedia.org/wiki/Data_segment
    # The prefixes tells about the segments that are present in the asm files
    # There are 450 segments(approx) present in all asm files.
    # These prefixes are best segments that gives us best values.
    # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:', '.data:', '.bss:', '.rdata:', '.edata:', '.rsrc:', '.tls:',
    #             '.reloc:', '.BSS:', '.CODE']

    # https://en.wikipedia.org/wiki/X86_instruction_listings
    # These are opcodes that are used to get best results
    opcodes = ['jmp', 'mov', 'retf', 'push', 'pop', 'xor', 'retn', 'nop', 'sub', 'inc', 'dec', 'add', 'imul', 'xchg',
               'or', 'shr', 'cmp', 'call', 'shl', 'ror', 'rol', 'jnb', 'jz', 'rtn', 'lea', 'movzx']

    # Below taken registers are general purpose registers and special registers
    # All the registers which are taken are best
    registers = ['edx', 'esi', 'eax', 'ebx', 'ecx', 'edi', 'ebp', 'esp', 'eip']

    # Best keywords that are taken from different blogs
    keywords = ['.dll', 'std::', ':dword']

    file1 = open(r"output\fourthprocess.txt", "w+")
    files = os.listdir('fourth')
    for f in files:
        # Filling the values with zeros into the arrays
        # prefixescount = np.zeros(len(prefixes), dtype=int)
        opcodescount = np.zeros(len(opcodes), dtype=int)
        keywordcount = np.zeros(len(keywords), dtype=int)
        registerscount = np.zeros(len(registers), dtype=int)
        features = []
        f2 = f.split('.')[0]
        file1.write(f2 + ",")
        # opcodefile.write(f2 + " ")

        # https://docs.python.org/3/library/codecs.html#codecs.ignore_errors
        # https://docs.python.org/3/library/codecs.html#codecs.Codec.encode
        with codecs.open('fourth/' + f, encoding='cp1252', errors='replace') as fli:
            for lines in fli:
                if lines in ['\n','\r\n'] or lines.strip() == "":
                    continue
                # https://www.tutorialspoint.com/python3/string_rstrip.htm
                line = lines.rstrip().split()
                l = line[0]

                # Counting the prefixs in each and every line
                # for i in range(len(prefixes)):
                #     if prefixes[i] in line[0]: # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:'...
                #         prefixescount[i] += 1
                # line = line[1:]

                # Counting the opcodes in each and every line
                for i in range(len(opcodes)):
                    if any(opcodes[i] == li for li in line):
                        features.append(opcodes[i])
                        opcodescount[i] += 1
                # Counting registers in the line
                for i in range(len(registers)):
                    for li in line:
                        # We will use registers only in 'text' and 'CODE' segments
                        # if registers[i] in li and ('text' in l or 'CODE' in l):
                        if registers[i] in li:
                            registerscount[i] += 1
                # Counting keywords in the line
                for i in range(len(keywords)):
                    for li in line:
                        if keywords[i] in li:
                            keywordcount[i] += 1
        # Pushing the values into the file after reading whole file
        # for prefix in prefixescount:
        #     file1.write(str(prefix) + ",")
        for opcode in opcodescount:
            file1.write(str(opcode) + ",")
        for register in registerscount:
            file1.write(str(register) + ",")
        for key in keywordcount:
            file1.write(str(key) + ",")
        file1.write("\n")
    file1.close()
def fifthprocess():
    asm_path = r"D:\research\datasets\3_malware\CCF_1_data_set\train_set\asm"
    os.chdir(asm_path)
    # https://en.wikipedia.org/wiki/Data_segment
    # The prefixes tells about the segments that are present in the asm files
    # There are 450 segments(approx) present in all asm files.
    # These prefixes are best segments that gives us best values.
    # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:', '.data:', '.bss:', '.rdata:', '.edata:', '.rsrc:', '.tls:',
    #             '.reloc:', '.BSS:', '.CODE']

    # https://en.wikipedia.org/wiki/X86_instruction_listings
    # These are opcodes that are used to get best results
    opcodes = ['jmp', 'mov', 'retf', 'push', 'pop', 'xor', 'retn', 'nop', 'sub', 'inc', 'dec', 'add', 'imul', 'xchg',
               'or', 'shr', 'cmp', 'call', 'shl', 'ror', 'rol', 'jnb', 'jz', 'rtn', 'lea', 'movzx']

    # Best keywords that are taken from different blogs
    keywords = ['.dll', 'std::', ':dword']

    # Below taken registers are general purpose registers and special registers
    # All the registers which are taken are best
    registers = ['edx', 'esi', 'eax', 'ebx', 'ecx', 'edi', 'ebp', 'esp', 'eip']

    file1 = open(r"output\fifthprocess.txt", "w+")
    files = os.listdir('fifth')
    for f in files:
        # Filling the values with zeros into the arrays
        # prefixescount = np.zeros(len(prefixes), dtype=int)
        opcodescount = np.zeros(len(opcodes), dtype=int)
        keywordcount = np.zeros(len(keywords), dtype=int)
        registerscount = np.zeros(len(registers), dtype=int)
        features = []
        f2 = f.split('.')[0]
        file1.write(f2 + ",")
        # opcodefile.write(f2 + " ")

        # https://docs.python.org/3/library/codecs.html#codecs.ignore_errors
        # https://docs.python.org/3/library/codecs.html#codecs.Codec.encode
        with codecs.open('fifth/' + f, encoding='cp1252', errors='replace') as fli:
            for lines in fli:
                if lines in ['\n','\r\n'] or lines.strip() == "":
                    continue
                # https://www.tutorialspoint.com/python3/string_rstrip.htm
                line = lines.rstrip().split()
                l = line[0]

                # Counting the prefixs in each and every line
                # for i in range(len(prefixes)):
                #     if prefixes[i] in line[0]: # prefixes = ['HEADER:', '.text:', '.Pav:', '.idata:'...
                #         prefixescount[i] += 1
                # line = line[1:]

                # Counting the opcodes in each and every line
                for i in range(len(opcodes)):
                    if any(opcodes[i] == li for li in line):
                        features.append(opcodes[i])
                        opcodescount[i] += 1
                # Counting registers in the line
                for i in range(len(registers)):
                    for li in line:
                        # We will use registers only in 'text' and 'CODE' segments
                        # if registers[i] in li and ('text' in l or 'CODE' in l):
                        if registers[i] in li:
                            registerscount[i] += 1
                # Counting keywords in the line
                for i in range(len(keywords)):
                    for li in line:
                        if keywords[i] in li:
                            keywordcount[i] += 1
        # Pushing the values into the file after reading whole file
        # for prefix in prefixescount:
        #     file1.write(str(prefix) + ",")
        for opcode in opcodescount:
            file1.write(str(opcode) + ",")
        for register in registerscount:
            file1.write(str(register) + ",")
        for key in keywordcount:
            file1.write(str(key) + ",")
        file1.write("\n")
    file1.close()

def main():
    manager=multiprocessing.Manager()
    p1=Process(target=firstprocess)
    p2=Process(target=secondprocess)
    p3=Process(target=thirdprocess)
    p4=Process(target=fourthprocess)
    p5=Process(target=fifthprocess)

    p1.start()
    p2.start()
    p3.start()
    p4.start()
    p5.start()

    p1.join()
    p2.join()
    p3.join()
    p4.join()
    p5.join()

if __name__ == "__main__":
    # asm_path = r"D:\research\datasets\3_malware\CCF_1_data_set\test\asm"
    main()