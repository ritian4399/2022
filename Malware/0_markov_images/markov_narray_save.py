import os
import glob
import numpy as np
import cv2
# from img_gist_feature.utils_gist import *
import time
import random
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Conv2D, MaxPooling2D
from tensorflow.keras.layers import Flatten

from tensorflow.keras.optimizers import SGD
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Activation
from tensorflow.keras import losses
from tensorflow.keras.layers import BatchNormalization
from tensorflow.keras.layers import LeakyReLU
from keras import regularizers
import keras
import tensorflow as tf
from tensorflow.python.framework import ops
ops.reset_default_graph()
import warnings
from tensorflow.python.client import device_lib
import datetime
print(device_lib.list_local_devices())


warnings.filterwarnings('ignore')
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
os.environ["CUDA_VISIBLE_DEVICES"] = "0"
# gist_helper = GistUtils()

# 保存markov运算后的结果
def print_info():
    print("tensorflow" + tf.__version__)
    print("keras" + keras.__version__)

    gpu = tf.test.is_gpu_available()
    if gpu:
        gpu_device_name = tf.test.gpu_device_name()
        print(gpu_device_name)
    else:
        print("no gpu")
def transition_matrix(arr, n=1):
    """"
    Computes the transition matrix from Markov chain sequence of order `n`.

    :param arr: Discrete Markov chain state sequence in discrete time with states in 0, ..., N
    :param n: Transition order
    """

    M = np.zeros(shape=(256, 256))
    for (i, j) in zip(arr, arr[1:]):
        M[i, j] += 1
    #print(M.sum())
    M_sum = np.ma.masked_equal(M.sum(axis=1), 0)
    T = (M.T / M_sum).T

    return np.linalg.matrix_power(T, n)


def num_img_fams_list():
  inp_dir = r"/root/malware/markov_images/datasets/malimg_paper_dataset_imgs"
  os.chdir(inp_dir)  #the parent fold with sub-folders
  list_fams = os.listdir(os.getcwd()) #vector of strings with family names
  no_imgs = [] # No. of samples per family

  for family in range(len(list_fams)):
     os.chdir(list_fams[family])
     no_per_family = len(glob.glob('*.png'))
     no_imgs.append(no_per_family)
     os.chdir('..')
  return no_imgs, list_fams


def getlabels(no_imgs, total):
    y = np.zeros(total) #label vector
    temp1 = np.zeros(len(no_imgs)+1)
    temp1[1:len(temp1)] = no_imgs #transform list to ndarray
    temp2 = int(temp1[0]) #used to be as lower bound, initially 0

    for label in range(len(no_imgs)):
       temp3 = temp2 + int(temp1[label+1]) #No. of imgs assigned labels from 2 round
       #print("temp3", temp3)
       #print("label", label)
       for index in range(temp2, temp3):# assigned labels to a fam of malware
            y[index] = label
       temp2 = temp2 + int(temp1[label + 1])
    #print(y[100:200])
    return np.array(y)


def getX(list_fams, total):
   trans_mat_arr = list() #pixel ranges between 0 and 255, in total 256
   total_time = 0
   min_time = 10
   for i in range(len(list_fams)):
      os.chdir(list_fams[i])
      img_list = glob.glob('*.png')# Getting only 'png' files in a folder
      for j in range(len(img_list)):
         img = cv2.imread(img_list[j], 0).flatten()

         tic = time.perf_counter()
         np_gist = transition_matrix(img)
         #print(np_gist.shape)
         toc = time.perf_counter()
         fir_step_time = toc - tic

         total_time = total_time + fir_step_time
         if fir_step_time < min_time:
             min_time = fir_step_time
         trans_mat_arr.append(np_gist)
         #print(f"the period of calling transition_matrix function in {fir_step_time:0.4f} seconds")
      os.chdir('..')
   print(f"the average time per image {total_time / total:0.4f} seconds")
   print(f"the fewest time taken for an image {min_time:0.4f} seconds")
   return np.array(trans_mat_arr)

def train():
    no_imgs, list_fams = num_img_fams_list() #a list storing num of images for each family
    print(no_imgs)
    total = sum(no_imgs) # total number of all samples
    print(total)
    X = getX(list_fams, total)
    y = getlabels(no_imgs, total)

    np.save("markov_images.npy", X)
    np.save("markov_images_label.npy", y)


if __name__ == "__main__":
          train()
